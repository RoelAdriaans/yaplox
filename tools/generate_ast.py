"""
Chapter 5 - Metaprogramming the trees
This utility creates the Python code that is our tree.
This util is not part of the source itselve and thus not tested. The generated files
are tested. The /tools/ folder *is* linted with black, mypy, isport and isort.
"""
import sys
from pathlib import Path
from typing import List

import black


class GenerateAst:
    def __init__(self, outputdir):
        self.outputdir = Path(outputdir)

    def generate_ast(self):
        self._create_output_directory()

        self._define_ast(
            base_name="Expr",
            types=[
                "Binary   : Expr left, Token operator, Expr right",
                "Grouping : Expr expression",
                "Literal  : Any value",
                "Unary    : Token operator, Expr right",
            ],
        )

    def _create_output_directory(self):
        """ Make sure the _create_output_directory exists"""
        if self.outputdir.exists() and self.outputdir.is_dir():
            return

        Path.mkdir(self.outputdir, parents=True)

    def _define_ast(self, base_name: str, types: List):
        lines = [
            "# This file has been auto-generated by tools/generate_ast.py",
            "# Do not edit this file by hand. Or do, but it will be overwritten",
            "",
            "from abc import ABC",
            "from typing import Any",
            "",
            "from yaplox.token import Token",
            "",
            "",
            f"class {base_name}(ABC):",
            "    ...",
            "",
        ]

        for class_type in types:
            class_name = class_type.split(":")[0].strip()
            fields = class_type.split(":")[1].strip()
            lines.extend(self._define_type(base_name, class_name, fields))

        self._write_file(base_name, lines)

    def _define_type(self, base_name: str, class_name: str, fields_list: str) -> List:
        # __init__ method
        fields = [field.strip().split() for field in fields_list.split(", ")]
        # split_fields = [field.split() for field in fields]
        init_fields = ", ".join(f"{field[1]}: {field[0]}" for field in fields)

        lines = [
            f"class {class_name}({base_name}):",
            f"    def __init__(self, {init_fields}):",
        ]

        for field in fields:
            lines.append(f"        self.{field[1]} = {field[1]}")

        return lines

    def _write_file(self, base_name: str, lines: List):
        """ Write all the lines"""
        output_file = self.outputdir / f"{base_name.lower()}.py"

        # Reformat the file with black. This way there is no need for difficult
        # list mangling
        file_contents = black.format_str("\n".join(lines), mode=black.FileMode())

        with open(output_file, "w") as f:
            # Add newlines, since writelines does not add those
            f.writelines(line for line in file_contents)


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <output_directory>")
        sys.exit(64)

    generate_ast = GenerateAst(sys.argv[1])
    generate_ast.generate_ast()
